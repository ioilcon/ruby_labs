# 5, 17, 29, 41, 53

def elements_processing(list, func, accumulator = [], el_pr = Proc.new {true}, ind_pr = Proc.new {true}, ind = 0)
    if ind == list.length() then
        accumulator
    else
        elements_processing(list, func, (el_pr.(list, ind) && ind_pr.(ind))?func.(list, ind, accumulator):accumulator, el_pr, ind_pr, ind + 1)
    end
end

def one_element_processing(list, func, accumulator = [], el_pr = Proc.new {true}, ind_pr = Proc.new {true})
    elements_processing(list, func, accumulator, el_pr, ind_pr).first()
end

# 5

def local_min(list, ind)
    one_element_processing(list, Proc.new {[true]}, [false], lambda { |list, ind| (ind == 0 || list[ind] < list[ind - 1]) && (ind == list.length() - 1 || list[ind] < list[ind + 1]) }, lambda { |cur_ind| cur_ind == ind})
end

def list_min(list)
    one_element_processing(list, lambda { |list, ind, acc| (list[ind] < acc.first())?[list[ind]]:acc}, [list.first()])
end

def list_max(list)
    one_element_processing(list, lambda { |list, ind, acc| (list[ind] > acc.first())?[list[ind]]:acc}, [list.first()])
end

def switch_min_max(list)
    elements_processing(list, lambda { |list, ind, acc| case when list[ind] == acc[0] then acc.push(acc[1]) when list[ind] == acc[1] then acc.push(acc[0]) else acc.push(list[ind]) end}, [list_min(list), list_max(list)])[2..]
end

p ([1,3,4,3,5,-1,2])
puts list_min([1,3,4,3,5,-1,2])
puts list_max([1,3,4,3,5,-1,2])
p switch_min_max([1,3,4,3,5,-1,2])
